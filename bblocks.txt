Log Structured Storage
    - space for objects stored + indexing data
    - db engines

    structure:
        - log: append-only sequence of data entries ( when writing new data, instead of finding
            location, just append to end of log ( metadata indexing appended same way ))
        - [ log block ][ index block ]  [ pointer to root node ]
        - split db in chuncks, when no index node pointing to a chunk, that chunk is removed
        - old db systems use complex lock system for transactional consistency
            - MVCC ( Multiversion Concurrency Control )
                - since existing data not modified in log-based storage system, read is done from
                  root index node
            - Optimistic Concurrency
                - look at the index and compare address pointer. if same address, no write occurred
                  if different address, transaction occurred. roll back and start from read phase

Design and Implementation of a Log-Structured File system
 
    - log file only file on disk w/ segmented/segment cleaner
    - CPU speeds were increasing but disk access constant
    - UNIX disk bandwidth 5-10%, rest of time seeking
    - crash reading from end of log file
    - segmented treats old, slow changing data differently from new, fast changing
    - log file leads to no seeks, order of magnitude increased write
    - assumption that files are memory cached, so mainly write traffic


Bitcask
    -   log structured hash table
    -   served as local key value store  
    -   bitcask instance is directory and only one OS process writes at a time
    -   when file reaches a certain limit, it is closed and not opened again
    -   active file written by appending, so no disk seeing
Rust
    std::collections


.iter(), .iter_mut(), .into_iter()